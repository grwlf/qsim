QSim
====

[[EN](./README.md)][RU]

QSim - простой квантовый симулятор, написанный на языке Python3 с использованием
библиотеки статической типизации [MyPy](https://github.com/python/mypy). Проект
написан в по заданию, полученному в ходе собеседования.

Симулятор состоит из трех основных модулей:

* [qsim.types](./src/qsim/types.py) Объявления типов данных.
* [qsim.core](./src/qsim/core.py) Базовый функцинальный API.
* [qsim.api1](./src/qsim/api1.py) Oбъектно-ориентированный API.

Тесты содержатся в файле [./tests/test_all.py](./tests/test_all.py)

Содержание
==========

1. [Установка](#установка)
2. [Примеры](#примеры)
3. [Функционал](#функционал)
4. [Ссылки](#ссылки)

Установка
=========

* Проект может быть собран с использрванием стандартных средств Python:
  `python3 setup.py install`.
* Также возможно использование без установки, для чего достаточно выставить
  переменную `export PYTHONPATH=$(pwd)/src:$PYTHONPATH`.
* Для сборки документации (файла README.md) используюется утлилита codebraid:
  `make README.md`
* Для запуска тестов следует выполнить команду `pytest`.
* Проект также содержит [правила](./shell.nix) для пакетного менеджера
  [Nix](https://nixos.org/nix), с помощью которых можно открыть окружение
  разработика со всеми установленными зависимостями. Для этого достаточно
  выполнить команду `nix-shell` в корневой директории проекта.

Примеры
=======

### Обзор ОО-API

Соответствует пп.2.1 (основная задача),2.2.1(установка количества кубит в
стартовом состоянии)

``` {.python .cb.nb show=code+stdout+stderr}
from qsim import circuit
c = circuit(qbit_count=2)
c.initialize([1,0])
c.h.on(0)
c.x.on(1)
c.execute()
print(c.opmatrix(0,1).mat)
```

*Замечание: результат отличается от примера в п.2.1 условия. Вероятно, разница в
порядке нумерации кубитов. Изменим порядок нумерации:*

``` {.python .cb.nb show=code+stdout+stderr}
print(c.opmatrix(1,0).mat)
```

### Параметризирвоанные операции

Соответствует пп.2.2.2

``` {.python .cb.nb show=code+stdout+stderr}
from math import pi
c = circuit(qbit_count=1)
c.initialize([1])
c.r(pi/2).on(0)
s = c.execute()
print(s[0].mat)
```

### Двухкубитные операции

Соответствует пп.2.2.3

``` {.python .cb.nb show=code+stdout+stderr}
c = circuit(qbit_count=2)
c.initialize([1,1])
c.cnot.on([0,1])
s = c.execute()
print(s[(0,1)].mat)
```

#### Использование базового функционального API.

``` {.python .cb.nb show=code+stdout+stderr}
from qsim import QGraph, addinput, addop, opX, opH, schedule, opmatrix, pairop
g=QGraph({})
i1,g=addinput(g,2)
o1,g=addop(g,pairop(opH(),opX()),[i1])
s=opmatrix(g,schedule(g))
print(s[o1].mat)
```

Функционал
==========

Типы данных
-----------

В симуляторе используются следующие группы данных:

1. Типы данных для задания условий симуляции:

   ```{.python .cb.code
       include_file=src/qsim/types.py
       include_after_string="# README:S1BEGIN"
       include_before_string="# README:S1END"}
   ```
   * `QVec` служит для задания векторов состояний. Элементы вектора состояний
     описывают коэффициенты при базисных векторах, соответствующих состоянию
     системы из N кубитов. Длина вектора должна быть 2^N.
     Пример: элементы вектора `QVec([a,b,c,d])` соответствуют коэффициентам при
     базисных векторах в таком порядке: `|00>`, `|01>`, `|10>`, `|11>`.
   * `QVecOp` тип-синоним, перечисляющий варианты описания квантовых операций:
     - `QBitOp` для задания операции в виде матрицы
     - `QTProd` для задания операции в виде вертикальной комбинации других
       операций

2. Типы данных для выполнения симуляции:

   ```{.python .cb.code
       include_file=src/qsim/types.py
       include_after_string="# README:S2BEGIN"
       include_before_string="# README:S2END"}
   ```

   * `QGraph` Описывает направленный граф квантовых операций, граф задан
     перечислением вершин и рёбер (через идентификаторы входных вершин). С
     узлами графа ассоциированы квантовые операции.
     Вспомогательные типы данных:
     - `QId` - Идентификатор узла. Тип-обертка над числом для удобства
       статической типизации.
     - `QInput` - Тип входного узла, значение которого должно быть задано
       пользователем перед началом симуляции.

Функции базового API
--------------------

Основной функционал реализован в модуле `qsim.core`. Также как и с типами, можно
выделить следующие основные группы функций:

1. Функции для задания условий симуляции
   1. Функции для операций над векторами состояний. Вектроы состояний можно
      создать функциями `mkvec` и `braket`. Из операций в отдельную функцию
      вынесены: получение тензорного произведения `tprod` и получение числа
      кубитов, задаваемых данным вектромо состояний.
      Функция `braket` реализована упрощенно, поддерживаются только значения `0`
      и `1`:
      Пример: варианты инициализации вектора состояний двух кубитов.
      ``` {.python .cb.nb show=code+stdout+stderr}
      from qsim.core import braket
      for q0 in [0,1]:
        for q1 in [0,1]:
          print(q0, q1, ':', braket([q0,q1]))
      ```
   2. Функции для операций над операциями. Простую операцию можно создавать из
      матрицы операции с помощью `qbitop` и из других операций с помощью
      `pairop`.

2. Операции с графом квантовых вычислений. В базовом API работа с графом
   производится в три этапа: формирование, планирование, свертка.
   1. Для формирования графа используются функции `addinput` и `addop`.
      Пример: задание графа из одной комбинированной 2-хкубитной операции с
      двумя однокубитными входами.
      ``` {.python .cb.nb show=code+stdout+stderr}
      from qsim import QGraph, addinput, addop, opX, opH, opI, pairop
      g=QGraph({})
      i1,g=addinput(g,1)
      i2,g=addinput(g,1)
      o1,g=addop(g,pairop(opH(),opX()),[i1,i2])
      print(g)
      ```
   2. Планирование вычислений представлено функцией `schedule` которая
      производит топологическую сортировку графа и возвращает список
      идентификаторов узлов, задавая тем самым очередность вычислений.
   3. Выполнение вычислений производят функции `evaluate` и `opmatrix`. Они
      могут быть использованы независимо друг от друга.

3. Функции предопределенных квантовых операций:
   ```{.python .cb.code
       include_file=src/qsim/core.py
       include_after_string="# README:FBEGIN"
       include_before_string="# README:FEND"}
   ```

Функции объектно-ориентированного API
-------------------------------------

Дизайн объектно ориентированного API задан в исходном ТЗ. Для его выполнения, к
типам данных добавлен тип именования состояния кубитов:

```{.python .cb.code
   include_file=src/qsim/api1.py
   include_after_string="# README:IBEGIN"
   include_before_string="# README:IEND"}
```

Примеры использования:

```{.python .cb.code}
0           # Состояние кубита 0
1           # Состояние кубита 1
(0,1)       # Связанное состояние кубитов 0 и 1
((0,1),2)   # Связанное состояние кубитов 0,1 и 2
```

Имя состояния кубитов используется для указания того, к какому состоянию
применить очередную операцию.

``` {.python .cb.nb show=code+stdout+stderr}
c = circuit(qbit_count=3)
c.initialize([0,0,0])
c.x.on([0])               # Применить операцию X к кубиту 0
c.cnot.on([0,1])          # Применить операцию CNOT к кубитам 0 и 1

opI3 = pairop(opI(),pairop(opI(),opI()))
c.op(opI3).on([(0,1),2])  # Применить 3х-кубитную ID к кубитам 0,1 и 2
```
После того как кубиты стали связанными в ходе применения операций,
объектно-ориентированное API не разрешает использовать кубиты по-отдельности.

``` {.python .cb.nb show=code+stdout+stderr}
try:
  c.cnot.on([0,1])
  assert False, "This should not happen"
except KeyError:
  pass
```

TODO

Расширения
----------

Соответствует пп.2.2.4.

### Поддержка новых типов операций

Для поддержки новых операций в базовом API достаточно описать их в виде функции
с использованием корректных типов данных.

Для добавление таких операций в объектно-ориентированное API достаточно
пронаследоваться от класса `Circuit` и доопределить в наследнике новую функцию
или свойство.

### Поддержка оптимизатора цепочек

Поскольку в качестве базовой структуры операций в данном симуляторе используется
граф, в нем легко могут быть доопределены алгоритмы из репертуара теории графов.

``` {.python .cb.code}
g=QGraph({})
i1,g=addinput(g,2)
o1,g=addop(g,pairop(opH(),opX()),[i1])
...
g2=optimize(g) # Callable[[QGraph],QGraph]
...
s=evaluate(g2,schedule(g2))
print(s[o1].mat)
```

### Поддержка новых типов бэкендов

Для поддержки новых типов бэкендов необходимо согласованно добавить
соответствующие функции планировки и расчетов. К примеру, вычисление на
воображаемом FPGA-процессоре может быть записано в базовом API так.

``` {.python .cb.code}
with fpga_resourse('/dev/fpga1') as r:
  g=QGraph({})
  i1,g=addinput(g,2)
  o1,g=addop(g,pairop(opH(),opX()),[i1])
  ...
  s=evaluate_FPGA(g,r,schedule_FPGA(g,r))
  print(s[o1].mat)
```

Ссылки
======

1. [Linear Algebra for Quantum Computation](https://link.springer.com/content/pdf/bbm%3A978-1-4614-6336-8%2F1.pdf)
2. [ScyPy](https://docs.sympy.org/latest/modules/physics/quantum/tensorproduct.html)
3. [Numpy Kron documentation](https://numpy.org/doc/stable/reference/generated/numpy.kron.html)

